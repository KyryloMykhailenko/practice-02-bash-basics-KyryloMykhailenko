[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/7kA7RYvI)
# Практика 02: Основи BASH

## Корисна інформація

### Рядок shebang

Shell-скрипт зазвичай починаються з рядка shebang: `#!path/to/interpreter`.

`#!` є зрозумілим для людини представленням магічного числа `0x23 0x21` яке може вказати оболонці передати виконання решти файлу вказаному інтерпретатору. Якщо ваш скрипт запускається як виконуваний файл (наприклад, `./my_shell_script`) з рядком shebang, тоді оболонка викличе виконуваний файл (зазвичай інтерпретатор) з `path/to/interpreter` щоб запустити ваш скрипт. Якщо ваш сценарій передається як аргумент інтерпретатору, наприклад, `bash my_shell_script`, тоді shebang не матиме ефекту і `bash` оброблятиме виконання скрипту.

**Чому це важливо?** Рядок shebang можна вважати корисною частиною метаданих, яка передає питання про те, як працює скрипт від користувача до автора програми. `my_shell_script` може бути скриптом `bash`, скриптом `python`, скриптом `ruby` тощо. Ідея полягає в тому, що для користувача, який викликає скрипт, має значення лише поведінка скрипту, а не деталі його реалізації.

Можливо, ви бачили такий варіант `#!/bin/sh`. Хоча спочатку він посилався на Bourne shell, у сучасних системах `sh` став посиланням на мову команд оболонки, яка є специфікацією POSIX із багатьма реалізаціями. `sh` зазвичай символічно пов'язаний (symlink) з однією з цих POSIX-сумісних оболонок, які реалізують командну мову оболонки. У Debian, наприклад, `sh` символічно пов’язано (symlink) з `dash` оболонкою.

Важливо зазначити, що `bash` не повністю відповідає цьому стандарту, хоча запуск bash як `bash --posix` робить його більш сумісним.

### Pipes

Ми можемо використовувати символ `|`, щоб об’єднати кілька команд в один рядок. Наприклад: `command1 | command2` передасть вихідні дані `command1` як вхідні дані для `command2`. Ми можемо повторювати це скільки завгодно разів.

### Корисні команди

#### [cat](https://man7.org/linux/man-pages/man1/cat.1.html)
`cat` друкує файли у стандартний вівід. Дуже корисно для друку чогось, щоб передати в інші команди!

#### [cut](https://man7.org/linux/man-pages/man1/cut.1.html)
`cut [параметри] [ім’я файлу]` витягує певні частини файлу (або передані вхідні дані) на основі аргументів, які використовуються. Деякі з них можуть бути корисними:
* `-d` дозволяє нам змінити роздільник або змінити символ, який шукає `cut`, щоб розділити рядок на частини. Якщо цей параметр пропущено, використовується tab (`\t`).
* `-f` дозволяє нам вказати число, яке відповідає полю, яке потрібно повернути, напр. `cut -f1 -d " "` поверне перше слово в реченні. Число, за яким стоїть `-`, також повертає всі поля після вказаного поля, тому `cut -f1- -d " "` повертатиме весь рядок.
* `--complement` вказує `cut` повертати все, крім зазначеного поля.

#### [grep](https://man7.org/linux/man-pages/man1/grep.1.html)
`grep [шаблон] [ім’я файлу]` відфільтровує та повертає рядки з файлу (або вхідних даних), які містять вказаний шаблон.

#### [sed](https://man7.org/linux/man-pages/man1/sed.1.html)
`sed` може робити багато речей, наприклад редагувати рядки та працювати з регулярними виразами. Ми можемо використовувати `sed`, щоб замінити один шаблон на інший таким чином:

```bash
sed 's/<ШАБЛОН ДЛЯ ЗАМІНИ>/<НОВИЙ ШАБЛОН>/g <ВВІД>';
```

`sed` також може приймати передані вхідні дані через pipe від іншої команди замість явного введення. `g` в кінці вказує `sed` замінити всі входження шаблону; його можна опустити, якщо ми хочемо замінити лише перше входження шаблону, або замінити числом, щоб замінити лише певну кількість входжень.

#### [xargs](https://man7.org/linux/man-pages/man1/xargs.1.html)
`xargs` дозволяє застосувати команду до виводу, переспрямованого з pipe. Наприклад, `output | xargs command` застосовує `command` до стандартного виводу `output`. Деякі корисні опції:
* `-n1` вказує `xargs` застосувати команду до кожного елемента в `output` один раз, якщо `output` містить кілька елементів (наприклад, список із кількох рядків)
* `-0` вказує `xargs` розділяти елементи у `output` за допомогою нульового символу, який означає кінець рядка, замість використання пробілів. У поєднанні з `-n1` це означає, що `xargs` застосовуватиме команду до кожного рядка, замість того, щоб розбивати рядки на окремі слова та застосовувати команду до кожного слова.

## Завдання
### Завдання 1

Використовуючи функції Bash та можливості розширення shell wildcard (`*`), напишіть скрипт `batchrename.sh`, щоб перейменувати розширення файлів у заданому каталозі. Необхідно, щоб цей скрипт:

- Приймав **три аргументи**:
  - **Каталог**: шлях до каталогу, в якому потрібно виконати перейменування.
  - **Оригінальне розширення**: розширення файлів, які потрібно перейменувати.
  - **Нове розширення**: розширення, на яке потрібно змінити.
- Для кожного перейменованого файлу друкував рядок з повідомленням: `Переіменовую <old_filename> на <new_filename>`.
- _Не змінював_ файли в каталозі, які не мають зазначеного оригінального розширення.

Наприклад:

```bash
# Створіть новий каталог tmp і додайте в нього 26 файлів a.dat, b.dat ... z.dat
$ mkdir tmp && touch tmp/{a..z}.dat

# Запустіть свій скрипт
$ ./batchrename.sh tmp dat txt
Переіменовую tmp/a.dat на tmp/a.txt
Переіменовую tmp/b.dat на tmp/b.txt
# ... ще 24 рядки про переіменування
Переіменовую tmp/z.dat на tmp/z.txt

# Перевірте кількість файлів з новим розширенням (має бути 26)
$ ls -1 tmp/*.txt | wc -l
26

# Переконайтеся, що файлів з оригінальним розширенням немає
$ ls -1 tmp/*.dat
ls: tmp/*.dat: No such file or directory
```

> Примітка: Не забудьте додати перевірку на наявність аргументів та правильність каталогу.

---

### Завдання 2

Використовуючи функції Bash, напишіть скрипт `filecreator.sh`, щоб створювати файли в поточному каталозі. Необхідно, щоб цей скрипт мав наступний функціонал:

- Створював 25 пустих (0 KB) файлів. (Підказка: можна використати команду `touch`).
  - Імена файлів повинні мати наступний формат: `<yourName><number>`, `<yourName><number+1>`, ..., і так далі.
- Кожного разу, коли ви його запускаєте, він повинен створювати _наступну групу з 25 файлів_ зі зростаючими номерами, починаючи з останнього або максимального числа, яке вже існує. Не кодуйте ці цифри жорстко; вони повинні генеруватися автоматично. (Підказка: для простоти можна використати підрахунок кількості існуючих файлів).

Наприклад:

```bash
# Запустіть свій скрипт, вказавши ваше ім'я як аргумент
$ ./filecreator.sh patron

# Перевірте поточну директорію. Ви повинні побачити 25 файлів з вашим ім'ям і числами від 1 до 25
$ ls
patron1  patron2  patron3  ...  patron25

# Видаліть останній файл
$ rm patron25

# Запустіть свій скрипт ще раз
$ ./filecreator.sh patron

# Перевірте поточну директорію. Тепер ви повинні побачити файли з числами до 49 (оскільки останній номер був 24)
$ ls
patron1  patron2  ... patron24  patron25  ... patron49
```

> Примітка: Перевірте, чи передано ім'я як аргумент. Якщо ні, виведіть повідомлення про використання.

---

## Завдання 3

Використовуючи функції Bash, напишіть скрипт `folderorganizer.sh`, щоб організувати файли в заданому каталозі за їх розширеннями. Необхідно, щоб цей скрипт:

- Приймав один аргумент: шлях до каталогу.
- Створював у цьому каталозі підкаталоги для кожного розширення файлів, що там присутні.
- Переміщував файли в відповідні підкаталоги за їх розширеннями.
- Друкував повідомлення для кожного файлу у форматі "Переміщую `<filename>` до `<extension>/`".

Наприклад:

```bash
# Створіть новий каталог files і додайте в нього файли різних типів
$ mkdir files && touch files/document1.txt files/image1.jpg files/document2.txt files/music1.mp3 files/image2.jpg

# Запустіть свій скрипт
$ ./folderorganizer.sh files
Переміщую files/document1.txt до txt/
Переміщую files/document2.txt до txt/
Переміщую files/image1.jpg до jpg/
Переміщую files/image2.jpg до jpg/
Переміщую files/music1.mp3 до mp3/

# Перевірте структуру каталогів
$ tree files
files
├── jpg
│   ├── image1.jpg
│   └── image2.jpg
├── mp3
│   └── music1.mp3
└── txt
    ├── document1.txt
    └── document2.txt
```

> Примітка: Не забудьте додати перевірку на наявність аргументів та правильність каталогу.

---

### Завдання 4

Використовуючи функції Bash та регулярні вирази, напишіть скрипт `logparser.sh`, щоб аналізувати файл журналу доступу веб-сервера. Необхідно, щоб цей скрипт:

- Приймав один аргумент: шлях до файлу журналу (наприклад, `access.log`).
- Визначав кількість унікальних IP-адрес, які зверталися до сервера.
- Визначав найпопулярніший ресурс (URL), який запитували.
- Друкував ці дані у форматі:
  - "Кількість унікальних IP: `<number>`"
  - "Найпопулярніший ресурс: `<resource>`"

Наприклад:

```bash
# Припустимо, у вас є файл access.log з наступним вмістом
$ cat access.log
192.168.1.10 - - [10/Oct/2023:13:55:36 +0000] "GET /index.html HTTP/1.1" 200 1024
192.168.1.11 - - [10/Oct/2023:13:56:40 +0000] "GET /about.html HTTP/1.1" 200 2048
192.168.1.10 - - [10/Oct/2023:13:57:15 +0000] "GET /contact.html HTTP/1.1" 200 512
192.168.1.12 - - [10/Oct/2023:13:58:22 +0000] "GET /index.html HTTP/1.1" 200 1024
192.168.1.11 - - [10/Oct/2023:13:59:01 +0000] "GET /index.html HTTP/1.1" 200 1024

# Запустіть свій скрипт
$ ./logparser.sh access.log
Кількість унікальних IP: 3
Найпопулярніший ресурс: /index.html
```

> Примітка: Перевірте, чи передано ім'я файлу як аргумент. Якщо ні, виведіть повідомлення про використання.

---

### Завдання 5

Використовуючи Bash scripting, напишіть скрипт `addressbook`, який реалізує просту адресну книгу з такими функціональними можливостями:

- Додавання нового запису:

  ```
  ./addressbook new <name> <email>
  ```

  - Додає запис до адресної книги.
  - Не турбуйтеся про дублікати; завжди додавайте новий запис, навіть якщо ім'я те саме.

- Відображення всіх записів:

  ```
  ./addressbook list
  ```

  - Відображає кожен запис в адресній книзі (без певного порядку).
  - Якщо в адресній книзі немає записів, відображає повідомлення: "Адресна книга порожня".

- Видалення записів за ім'ям:

  ```
  ./addressbook remove <name>
  ```

  - Видаляє всі записи, пов'язані з цим іменем.
  - Якщо цього імені немає в адресній книзі, нічого не робить.

- Очищення адресної книги:

  ```
  ./addressbook clear
  ```

  - Видаляє всю адресну книгу.

- Пошук записів за ім'ям:

  ```
  ./addressbook lookup <name>
  ```

  - Відображає всі електронні адреси, пов'язані з цим іменем.
  - Ви можете припустити, що всі електронні адреси мають форму `aaa@aaa.aaa`, де `aaa` — будь-яка кількість цифр або літер.
  - Ви можете надрукувати ім'я разом з електронною адресою для кожного запису.

Наприклад:

```bash
$ ./addressbook new "John Doe" a@gmail.com

$ ./addressbook list
John Doe a@gmail.com

$ ./addressbook new "Pes Patron" p@gmail.com

$ ./addressbook new "John Doe" b@gmail.com

$ ./addressbook list
John Doe a@gmail.com
Pes Patron p@gmail.com
John Doe b@gmail.com

# Опціональна поведінка
$ ./addressbook lookup "John Doe"
a@gmail.com
b@gmail.com

# Альтернативна поведінка
$ ./addressbook lookup "John Doe"
John Doe a@gmail.com
John Doe b@gmail.com

$ ./addressbook remove "John Doe"

$ ./addressbook list
Pes Patron p@gmail.com

$ ./addressbook clear

$ ./addressbook list
Адресна книга порожня
```

> Примітка: для спрощення можна припустити, що формат email завжди коректний.

Додаткові вимоги:

- Як "базу даних" для адресної книги необхідно використовувати звичайний текстовий файл.
- Всі операції повинні працювати з цим файлом.
- Перед виконанням операцій необхідно перевірити, чи існує цей файл, і за необхідності створити його.
